-- =============================================================================
-- BDIP Business Logic Functions
-- Version: 20250103000000_create_business_functions.sql
-- Purpose: Implement core business algorithms for engagement scoring and routing
-- =============================================================================

-- =============================================================================
-- ENGAGEMENT SCORING FUNCTIONS
-- =============================================================================

-- Calculate average response time for a barrister
CREATE OR REPLACE FUNCTION public.calculate_avg_response_time(barrister_uuid UUID)
RETURNS DECIMAL(6,2) AS $$
DECLARE
  avg_hours DECIMAL(6,2);
BEGIN
  SELECT COALESCE(AVG(response_time_hours), 24.0)
  INTO avg_hours
  FROM public.enquiries 
  WHERE assigned_barrister_id = barrister_uuid
  AND response_time_hours IS NOT NULL
  AND responded_at IS NOT NULL
  AND created_at >= NOW() - INTERVAL '90 days'; -- Last 90 days
  
  RETURN COALESCE(avg_hours, 24.0);
END;
$$ LANGUAGE plpgsql STABLE;

-- Calculate conversion rate for a barrister
CREATE OR REPLACE FUNCTION public.calculate_conversion_rate(barrister_uuid UUID)
RETURNS DECIMAL(4,3) AS $$
DECLARE
  total_enquiries INTEGER;
  converted_enquiries INTEGER;
  conversion_rate DECIMAL(4,3);
BEGIN
  SELECT 
    COUNT(*) as total,
    COUNT(CASE WHEN status = 'Converted' THEN 1 END) as converted
  INTO total_enquiries, converted_enquiries
  FROM public.enquiries 
  WHERE assigned_barrister_id = barrister_uuid
  AND created_at >= NOW() - INTERVAL '90 days'; -- Last 90 days
  
  IF total_enquiries = 0 THEN
    RETURN 0.500; -- Default 50% for new barristers
  END IF;
  
  conversion_rate := converted_enquiries::DECIMAL / total_enquiries::DECIMAL;
  RETURN COALESCE(conversion_rate, 0.000);
END;
$$ LANGUAGE plpgsql STABLE;

-- Calculate revenue generated by a barrister
CREATE OR REPLACE FUNCTION public.calculate_revenue_generated(barrister_uuid UUID)
RETURNS DECIMAL(12,2) AS $$
DECLARE
  total_revenue DECIMAL(12,2);
BEGIN
  SELECT COALESCE(SUM(actual_value), 0.00)
  INTO total_revenue
  FROM public.enquiries 
  WHERE assigned_barrister_id = barrister_uuid
  AND status = 'Converted'
  AND converted_at >= NOW() - INTERVAL '90 days'; -- Last 90 days
  
  RETURN COALESCE(total_revenue, 0.00);
END;
$$ LANGUAGE plpgsql STABLE;

-- Calculate client satisfaction score (placeholder - would integrate with feedback system)
CREATE OR REPLACE FUNCTION public.calculate_client_satisfaction(barrister_uuid UUID)
RETURNS DECIMAL(3,2) AS $$
DECLARE
  avg_quality DECIMAL(3,2);
BEGIN
  -- Calculate average quality score from completed tasks
  SELECT COALESCE(AVG(quality_score), 3.5)
  INTO avg_quality
  FROM public.tasks 
  WHERE barrister_id = barrister_uuid
  AND quality_score IS NOT NULL
  AND completed_at >= NOW() - INTERVAL '90 days';
  
  RETURN COALESCE(avg_quality, 3.5); -- Default to 3.5/5
END;
$$ LANGUAGE plpgsql STABLE;

-- Main engagement score calculation function
CREATE OR REPLACE FUNCTION public.calculate_engagement_score(barrister_uuid UUID)
RETURNS DECIMAL(5,2) AS $$
DECLARE
  response_time DECIMAL(6,2);
  conversion_rate DECIMAL(4,3);
  client_satisfaction DECIMAL(3,2);
  revenue_generated DECIMAL(12,2);
  
  response_score DECIMAL(5,2);
  conversion_score DECIMAL(5,2);
  satisfaction_score DECIMAL(5,2);
  revenue_score DECIMAL(5,2);
  
  final_score DECIMAL(5,2);
BEGIN
  -- Get component metrics
  response_time := public.calculate_avg_response_time(barrister_uuid);
  conversion_rate := public.calculate_conversion_rate(barrister_uuid);
  client_satisfaction := public.calculate_client_satisfaction(barrister_uuid);
  revenue_generated := public.calculate_revenue_generated(barrister_uuid);
  
  -- Calculate component scores (0-100 scale)
  -- Response Time Score: 100 - (hours * 4), capped at 0-100
  response_score := GREATEST(0, LEAST(100, 100 - (response_time * 4)));
  
  -- Conversion Rate Score: percentage * 100
  conversion_score := LEAST(100, conversion_rate * 100);
  
  -- Satisfaction Score: rating * 20 (5-point scale to 100)
  satisfaction_score := LEAST(100, client_satisfaction * 20);
  
  -- Revenue Score: revenue / 1000, capped at 100
  revenue_score := LEAST(100, revenue_generated / 1000);
  
  -- Weighted final score
  final_score := (
    response_score * 0.30 +      -- 30% weight
    conversion_score * 0.40 +    -- 40% weight  
    satisfaction_score * 0.20 +  -- 20% weight
    revenue_score * 0.10         -- 10% weight
  );
  
  RETURN ROUND(final_score, 2);
END;
$$ LANGUAGE plpgsql STABLE;

-- =============================================================================
-- CONVERSION PROBABILITY FUNCTIONS
-- =============================================================================

-- Calculate conversion probability for an enquiry
CREATE OR REPLACE FUNCTION public.calculate_conversion_probability(enquiry_uuid UUID)
RETURNS DECIMAL(4,3) AS $$
DECLARE
  enquiry_record public.enquiries;
  client_record public.clients;
  probability DECIMAL(4,3) := 0.500; -- Base probability 50%
BEGIN
  -- Get enquiry details
  SELECT e.*, c.*
  INTO enquiry_record, client_record
  FROM public.enquiries e
  LEFT JOIN public.clients c ON c.id = e.client_id
  WHERE e.id = enquiry_uuid;
  
  IF NOT FOUND THEN
    RETURN 0.500; -- Default if enquiry not found
  END IF;
  
  -- Historical client bonus (+20%)
  IF client_record.matter_count > 0 THEN
    probability := probability + 0.200;
  END IF;
  
  -- Response time adjustments
  IF enquiry_record.response_time_hours IS NOT NULL THEN
    IF enquiry_record.response_time_hours < 2 THEN
      probability := probability + 0.150; -- +15% for very fast response
    ELSIF enquiry_record.response_time_hours < 24 THEN
      probability := probability + 0.050; -- +5% for fast response
    ELSE
      probability := probability - 0.100; -- -10% for slow response
    END IF;
  END IF;
  
  -- Value indicators (+10% for high value)
  IF enquiry_record.estimated_value > 50000 THEN
    probability := probability + 0.100;
  END IF;
  
  -- Source quality adjustments
  CASE enquiry_record.source
    WHEN 'Referral' THEN probability := probability + 0.150; -- +15% for referrals
    WHEN 'Website' THEN probability := probability - 0.050; -- -5% for website leads
    WHEN 'Direct' THEN probability := probability + 0.100;  -- +10% for direct contact
    ELSE NULL; -- No adjustment for Email, Phone
  END CASE;
  
  -- Urgency adjustments
  CASE enquiry_record.urgency
    WHEN 'Immediate' THEN probability := probability + 0.080; -- +8% for urgent matters
    WHEN 'Flexible' THEN probability := probability - 0.030;  -- -3% for flexible timing
    ELSE NULL; -- No adjustment for This Week, This Month
  END CASE;
  
  -- Practice area historical performance (simplified)
  -- In a real system, this would query historical data by practice area
  IF enquiry_record.practice_area IN ('Commercial', 'Employment', 'Clinical Negligence') THEN
    probability := probability + 0.050; -- +5% for high-conversion practice areas
  END IF;
  
  -- Cap probability between 5% and 95%
  probability := GREATEST(0.050, LEAST(0.950, probability));
  
  RETURN ROUND(probability, 3);
END;
$$ LANGUAGE plpgsql STABLE;

-- =============================================================================
-- ENQUIRY ROUTING FUNCTIONS
-- =============================================================================

-- Find best barrister for an enquiry
CREATE OR REPLACE FUNCTION public.find_best_barrister(
  enquiry_uuid UUID,
  practice_area_param TEXT DEFAULT NULL,
  complexity_param TEXT DEFAULT 'Medium',
  estimated_value_param DECIMAL DEFAULT 0,
  urgency_param TEXT DEFAULT 'Flexible'
)
RETURNS UUID AS $$
DECLARE
  best_barrister_id UUID;
  best_score DECIMAL(8,4) := -1;
  barrister_record RECORD;
  current_score DECIMAL(8,4);
  workload_factor DECIMAL(4,3);
BEGIN
  -- Loop through available barristers
  FOR barrister_record IN 
    SELECT 
      b.id,
      b.practice_areas,
      b.seniority,
      b.engagement_score,
      b.current_workload,
      b.max_workload,
      b.is_active
    FROM public.barristers b
    WHERE b.is_active = true 
    AND b.deleted_at IS NULL
    AND b.current_workload < b.max_workload
  LOOP
    -- Check practice area match (required)
    IF practice_area_param IS NOT NULL AND 
       NOT (practice_area_param = ANY(barrister_record.practice_areas)) THEN
      CONTINUE;
    END IF;
    
    -- Check complexity/seniority requirements
    IF complexity_param = 'Complex' AND barrister_record.seniority = 'Pupil' THEN
      CONTINUE;
    END IF;
    
    -- Check value/seniority requirements for high-value matters
    IF estimated_value_param > 100000 AND 
       barrister_record.seniority NOT IN ('Senior', 'KC') THEN
      CONTINUE;
    END IF;
    
    -- Calculate workload factor (0.0 = fully loaded, 1.0 = no load)
    workload_factor := 1.0 - (barrister_record.current_workload::DECIMAL / barrister_record.max_workload::DECIMAL);
    
    -- Calculate combined score: engagement score * workload availability
    current_score := barrister_record.engagement_score * workload_factor;
    
    -- Urgency bonus for senior barristers on urgent matters
    IF urgency_param = 'Immediate' AND barrister_record.seniority IN ('Senior', 'KC') THEN
      current_score := current_score * 1.1; -- 10% bonus
    END IF;
    
    -- Track best barrister
    IF current_score > best_score THEN
      best_score := current_score;
      best_barrister_id := barrister_record.id;
    END IF;
  END LOOP;
  
  RETURN best_barrister_id;
END;
$$ LANGUAGE plpgsql STABLE;

-- =============================================================================
-- WORKLOAD MANAGEMENT FUNCTIONS  
-- =============================================================================

-- Update barrister workload based on active enquiries and tasks
CREATE OR REPLACE FUNCTION public.update_barrister_workload(barrister_uuid UUID)
RETURNS INTEGER AS $$
DECLARE
  active_enquiries INTEGER;
  pending_tasks INTEGER;
  total_workload INTEGER;
BEGIN
  -- Count active enquiries
  SELECT COUNT(*)
  INTO active_enquiries
  FROM public.enquiries 
  WHERE assigned_barrister_id = barrister_uuid
  AND status IN ('Assigned', 'In Progress')
  AND deleted_at IS NULL;
  
  -- Count pending tasks (weighted)
  SELECT COALESCE(SUM(
    CASE 
      WHEN priority = 'Urgent' THEN 3
      WHEN priority = 'High' THEN 2
      WHEN priority = 'Medium' THEN 1
      ELSE 1
    END
  ), 0)
  INTO pending_tasks
  FROM public.tasks 
  WHERE barrister_id = barrister_uuid
  AND status IN ('Pending', 'In Progress')
  AND deleted_at IS NULL;
  
  -- Calculate total workload
  total_workload := active_enquiries + (pending_tasks / 2); -- Tasks worth 0.5 enquiry each
  
  -- Update barrister record
  UPDATE public.barristers 
  SET 
    current_workload = total_workload,
    updated_at = NOW()
  WHERE id = barrister_uuid;
  
  RETURN total_workload;
END;
$$ LANGUAGE plpgsql;

-- Update clerk workload based on assigned enquiries
CREATE OR REPLACE FUNCTION public.update_clerk_workload(clerk_uuid UUID)
RETURNS INTEGER AS $$
DECLARE
  active_enquiries INTEGER;
BEGIN
  -- Count enquiries assigned to this clerk
  SELECT COUNT(*)
  INTO active_enquiries
  FROM public.enquiries 
  WHERE assigned_clerk_id = clerk_uuid
  AND status IN ('New', 'Assigned', 'In Progress')
  AND deleted_at IS NULL;
  
  -- Update clerk record
  UPDATE public.clerks 
  SET 
    current_workload = active_enquiries,
    updated_at = NOW()
  WHERE id = clerk_uuid;
  
  RETURN active_enquiries;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- BATCH PROCESSING FUNCTIONS
-- =============================================================================

-- Update all engagement scores (for scheduled job)
CREATE OR REPLACE FUNCTION public.update_all_engagement_scores()
RETURNS INTEGER AS $$
DECLARE
  updated_count INTEGER := 0;
  barrister_record RECORD;
  new_score DECIMAL(5,2);
BEGIN
  FOR barrister_record IN 
    SELECT id FROM public.barristers 
    WHERE is_active = true AND deleted_at IS NULL
  LOOP
    new_score := public.calculate_engagement_score(barrister_record.id);
    
    UPDATE public.barristers 
    SET 
      engagement_score = new_score,
      updated_at = NOW()
    WHERE id = barrister_record.id;
    
    updated_count := updated_count + 1;
  END LOOP;
  
  RETURN updated_count;
END;
$$ LANGUAGE plpgsql;

-- Update all conversion probabilities for active enquiries
CREATE OR REPLACE FUNCTION public.update_all_conversion_probabilities()
RETURNS INTEGER AS $$
DECLARE
  updated_count INTEGER := 0;
  enquiry_record RECORD;
  new_probability DECIMAL(4,3);
BEGIN
  FOR enquiry_record IN 
    SELECT id FROM public.enquiries 
    WHERE status IN ('New', 'Assigned', 'In Progress')
    AND deleted_at IS NULL
  LOOP
    new_probability := public.calculate_conversion_probability(enquiry_record.id);
    
    UPDATE public.enquiries 
    SET 
      conversion_probability = new_probability,
      updated_at = NOW()
    WHERE id = enquiry_record.id;
    
    updated_count := updated_count + 1;
  END LOOP;
  
  RETURN updated_count;
END;
$$ LANGUAGE plpgsql;

-- Update all workloads (for scheduled job)
CREATE OR REPLACE FUNCTION public.update_all_workloads()
RETURNS JSONB AS $$
DECLARE
  barrister_count INTEGER := 0;
  clerk_count INTEGER := 0;
  barrister_record RECORD;
  clerk_record RECORD;
BEGIN
  -- Update barrister workloads
  FOR barrister_record IN 
    SELECT id FROM public.barristers 
    WHERE is_active = true AND deleted_at IS NULL
  LOOP
    PERFORM public.update_barrister_workload(barrister_record.id);
    barrister_count := barrister_count + 1;
  END LOOP;
  
  -- Update clerk workloads
  FOR clerk_record IN 
    SELECT id FROM public.clerks 
    WHERE deleted_at IS NULL
  LOOP
    PERFORM public.update_clerk_workload(clerk_record.id);
    clerk_count := clerk_count + 1;
  END LOOP;
  
  RETURN jsonb_build_object(
    'barristers_updated', barrister_count,
    'clerks_updated', clerk_count,
    'updated_at', NOW()
  );
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- GRANT PERMISSIONS
-- =============================================================================

-- Grant execute permissions to authenticated users for read-only functions
GRANT EXECUTE ON FUNCTION public.calculate_avg_response_time TO authenticated;
GRANT EXECUTE ON FUNCTION public.calculate_conversion_rate TO authenticated;
GRANT EXECUTE ON FUNCTION public.calculate_revenue_generated TO authenticated;
GRANT EXECUTE ON FUNCTION public.calculate_client_satisfaction TO authenticated;
GRANT EXECUTE ON FUNCTION public.calculate_engagement_score TO authenticated;
GRANT EXECUTE ON FUNCTION public.calculate_conversion_probability TO authenticated;
GRANT EXECUTE ON FUNCTION public.find_best_barrister TO authenticated;

-- Grant execute permissions for workload functions (clerks and admins only via RLS)
GRANT EXECUTE ON FUNCTION public.update_barrister_workload TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_clerk_workload TO authenticated;

-- Grant execute permissions for batch functions (system/admin only)
GRANT EXECUTE ON FUNCTION public.update_all_engagement_scores TO service_role;
GRANT EXECUTE ON FUNCTION public.update_all_conversion_probabilities TO service_role;
GRANT EXECUTE ON FUNCTION public.update_all_workloads TO service_role;

-- =============================================================================
-- BUSINESS FUNCTIONS COMPLETE
-- =============================================================================

-- Log migration completion
INSERT INTO _supabase_migrations (version) VALUES ('20250103000000') 
ON CONFLICT (version) DO NOTHING;